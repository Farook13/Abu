import os
import logging
import random
import asyncio
import pytz
from Script import script
from datetime import datetime
from pyrogram import Client, filters, enums
from pyrogram.errors import ChatAdminRequired, FloodWait
from pyrogram.types import *
from database.ia_filterdb import Media, get_file_details, unpack_new_file_id, get_bad_files
from database.users_chats_db import db
from info import CHANNELS, ADMINS, AUTH_CHANNEL, PICS, BATCH_FILE_CAPTION, CUSTOM_FILE_CAPTION, PROTECT_CONTENT, CHNL_LNK, GRP_LNK, REQST_CHANNEL, SUPPORT_CHAT_ID, SUPPORT_CHAT, MAX_B_TN, VERIFY, HOWTOVERIFY, SHORTLINK_API, SHORTLINK_URL, TUTORIAL, IS_TUTORIAL, PREMIUM_USER, PICS, SUBSCRIPTION
from utils import get_settings, get_size, is_req_subscribed, save_group_settings, temp, verify_user, check_token, check_verification, get_token, get_shortlink, get_tutorial
from database.connections_mdb import active_connection
# from plugins.pm_filter import ENABLE_SHORTLINK
import re, asyncio, os, sys
import json
import base64
logger = logging.getLogger(__name__)

TIMEZONE = "Asia/Kolkata"
BATCH_FILES = {}

@Client.on_message(filters.command("start") & filters.incoming)
async def start(client, message):
    # Handle group/supergroup chats
    if message.chat.type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        buttons = [
            [InlineKeyboardButton('‚òÜ ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò ‚òÜ', url=f'http://t.me/{temp.U_NAME}?startgroup=true')],
            [InlineKeyboardButton('üçÅ  ú·¥è·¥° ·¥õ·¥è ·¥úÍú±·¥á üçÅ', url=f"https://t.me/{temp.U_NAME}?start=help")]
        ]
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply(script.GSTART_TXT.format(
            message.from_user.mention if message.from_user else message.chat.title, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup, disable_web_page_preview=True)
        # Check and log new group without delay
        if not await db.get_chat(message.chat.id):
            total = await client.get_chat_members_count(message.chat.id)
            await client.send_message(LOG_CHANNEL, script.LOG_TEXT_G.format(message.chat.title, message.chat.id, total, "Unknown"))
            await db.add_chat(message.chat.id, message.chat.title)
        return

    # Handle private chats
    user_id = message.from_user.id
    # Add user to DB if not exists (assumes this is fast or can be cached)
    if not await db.is_user_exist(user_id):
        await db.add_user(user_id, message.from_user.first_name)
        await client.send_message(LOG_CHANNEL, script.LOG_TEXT_P.format(user_id, message.from_user.mention))

    # Default start command (no arguments or simple cases)
    if len(message.command) != 2:
        current_time = datetime.now(pytz.timezone(TIMEZONE))
        curr_time = current_time.hour
        gtxt = ("…¢·¥è·¥è·¥Ö ·¥ç·¥è Ä…¥…™…¥…¢ üëã" if curr_time < 12 else
                "…¢·¥è·¥è·¥Ö ·¥Ä“ì·¥õ·¥á Ä…¥·¥è·¥è…¥ üëã" if curr_time < 17 else
                "…¢·¥è·¥è·¥Ö ·¥á·¥†·¥á…¥…™…¥…¢ üëã" if curr_time < 21 else
                "…¢·¥è·¥è·¥Ö …¥…™…¢ ú·¥õ üëã")
        buttons = [
            [InlineKeyboardButton('‚òÜ ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò ‚òÜ', url=f'http://telegram.me/{temp.U_NAME}?startgroup=true')],
            [InlineKeyboardButton('üí∏ ·¥á·¥Ä Ä…¥ ·¥ç·¥è…¥·¥á è üí∏', callback_data="shortlink_info"),
             InlineKeyboardButton('‚Ä¢ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ‚Ä¢', callback_data='channels')],
            [InlineKeyboardButton('‚Ä¢ ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥ÖÍú± ‚Ä¢', callback_data='help'),
             InlineKeyboardButton('‚Ä¢ ·¥Ä ô·¥è·¥ú·¥õ ‚Ä¢', callback_data='about')],
            [InlineKeyboardButton('‚ú®  ô·¥ú è Íú±·¥ú ôÍú±·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥ :  Ä·¥á·¥ç·¥è·¥†·¥á ·¥Ä·¥ÖÍú± ‚ú®', callback_data="premium_info")]
        ]
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply_photo(
            photo=random.choice(PICS),
            caption=script.START_TXT.format(message.from_user.mention, gtxt, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        return

    # Handle subscription check for private chats with arguments
    if AUTH_CHANNEL and not await is_req_subscribed(client, message):
        try:
            invite_link = await client.create_chat_invite_link(int(AUTH_CHANNEL), creates_join_request=True)
        except ChatAdminRequired:
            logger.error("Make sure Bot is admin in Forcesub channel")
            return
        btn = [[InlineKeyboardButton("üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå", url=invite_link.invite_link)]]
        if message.command[1] != "subscribe":
            try:
                kk, file_id = message.command[1].split("_", 1)
                btn.append([InlineKeyboardButton("‚Üª T Ä è A…¢·¥Ä…™…¥", callback_data=f"checksub#{kk}#{file_id}")])
            except (IndexError, ValueError):
                btn.append([InlineKeyboardButton("‚Üª T Ä è A…¢·¥Ä…™…¥", url=f"https://t.me/{temp.U_NAME}?start={message.command[1]}")])
        await client.send_message(
            chat_id=user_id,
            text="·¥ä·¥è…™…¥ ·¥è·¥ú Ä ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü ·¥Ä…¥·¥Ö ·¥õ ú·¥á…¥ ·¥Ñ ü…™·¥Ñ·¥ã ·¥è…¥ ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥ ·¥õ·¥è …¢·¥á·¥õ  è·¥è·¥ú Ä  Ä·¥á«´·¥ú·¥áÍú±·¥õ·¥á·¥Ö Íú∞…™ ü·¥á.",
            reply_markup=InlineKeyboardMarkup(btn),
            parse_mode=enums.ParseMode.MARKDOWN
        )
        return

    # Handle special cases like "subscribe", "premium", etc.
    data = message.command[1]
    if data in ["subscribe", "error", "okay", "help"]:
        current_time = datetime.now(pytz.timezone(TIMEZONE))
        curr_time = current_time.hour
        gtxt = ("…¢·¥è·¥è·¥Ö ·¥ç·¥è Ä…¥…™…¥…¢ üëã" if curr_time < 12 else
                "…¢·¥è·¥è·¥Ö ·¥Ä“ì·¥õ·¥á Ä…¥·¥è·¥è…¥ üëã" if curr_time < 17 else
                "…¢·¥è·¥è·¥Ö ·¥á·¥†·¥á…¥…™…¥…¢ üëã" if curr_time < 21 else
                "…¢·¥è·¥è·¥Ö …¥…™…¢ ú·¥õ üëã")
        buttons = [
            [InlineKeyboardButton('‚òÜ ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò ‚òÜ', url=f'http://telegram.me/{temp.U_NAME}?startgroup=true')],
            [InlineKeyboardButton('üí∏ ·¥á·¥Ä Ä…¥ ·¥ç·¥è…¥·¥á è üí∏', callback_data="shortlink_info"),
             InlineKeyboardButton('‚Ä¢ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ‚Ä¢', callback_data='channels')],
            [InlineKeyboardButton('‚Ä¢ ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥ÖÍú± ‚Ä¢', callback_data='help'),
             InlineKeyboardButton('‚Ä¢ ·¥Ä ô·¥è·¥ú·¥õ ‚Ä¢', callback_data='about')],
            [InlineKeyboardButton('‚ú®  ô·¥ú è Íú±·¥ú ôÍú±·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥ :  Ä·¥á·¥ç·¥è·¥†·¥á ·¥Ä·¥ÖÍú± ‚ú®', callback_data="premium_info")]
        ]
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply_photo(
            photo=random.choice(PICS),
            caption=script.START_TXT.format(message.from_user.mention, gtxt, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        return

    if data == "premium":
        buttons = [
            [InlineKeyboardButton('üì≤ Íú±·¥á…¥·¥Ö ·¥ò·¥Ä è·¥ç·¥á…¥·¥õ Íú±·¥Ñ Ä·¥á·¥á…¥Íú± ú·¥è·¥õ', user_id=int(6695586027))],
            [InlineKeyboardButton('‚ùå ·¥Ñ ü·¥èÍú±·¥á ‚ùå', callback_data='close_data')]
        ]
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply_photo(
            photo=SUBSCRIPTION,
            caption=script.PREPLANS_TXT.format(message.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        return

    # File handling logic (unchanged)
    try:
        pre, file_id = data.split('_', 1)
    except:
        file_id = data
        pre = ""
    if data.split("-", 1)[0] == "BATCH":
        sts = await message.reply("<b>Please wait...</b>")
        file_id = data.split("-", 1)[1]
        msgs = BATCH_FILES.get(file_id)
        if not msgs:
            file = await client.download_media(file_id)
            try: 
                with open(file) as file_data:
                    msgs=json.loads(file_data.read())
            except:
                await sts.edit("FAILED")
                return await client.send_message(LOG_CHANNEL, "UNABLE TO OPEN FILE.")
            os.remove(file)
            BATCH_FILES[file_id] = msgs
        for msg in msgs:
            title = msg.get("title")
            size=get_size(int(msg.get("size", 0)))
            f_caption=msg.get("caption", "")
            if BATCH_FILE_CAPTION:
                try:
                    f_caption=BATCH_FILE_CAPTION.format(file_name= '' if title is None else title, file_size='' if size is None else size, file_caption='' if f_caption is None else f_caption)
                except Exception as e:
                    logger.exception(e)
                    f_caption=f_caption
            if f_caption is None:
                f_caption = f"{title}"
            try:
                await client.send_cached_media(
                    chat_id=message.from_user.id,
                    file_id=msg.get("file_id"),
                    caption=f_caption,
                    protect_content=msg.get('protect', False),
                    reply_markup=InlineKeyboardMarkup(
                        [
                            [InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üßø', callback_data=f'generate_stream_link:{file_id}')],
                            [InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=f'')]
                        ]
                    )
                )
            except FloodWait as e:
                await asyncio.sleep(e.x)
                logger.warning(f"Floodwait of {e.x} sec.")
                await client.send_cached_media(
                    chat_id=message.from_user.id,
                    file_id=msg.get("file_id"),
                    caption=f_caption,
                    protect_content=msg.get('protect', False),
                    reply_markup=InlineKeyboardMarkup(
                        [
                            [InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üßø', callback_data=f'generate_stream_link:{file_id}')],
                            [InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=f'https://t.me/moviegroupbat')]
                        ]
                    )
                )
            except Exception as e:
                logger.warning(e, exc_info=True)
                continue
            await asyncio.sleep(1) 
        await sts.delete()
        return
    
    elif data.split("-", 1)[0] == "DSTORE":
        sts = await message.reply("<b>Please wait...</b>")
        b_string = data.split("-", 1)[1]
        decoded = (base64.urlsafe_b64decode(b_string + "=" * (-len(b_string) % 4))).decode("ascii")
        try:
            f_msg_id, l_msg_id, f_chat_id, protect = decoded.split("_", 3)
        except:
            f_msg_id, l_msg_id, f_chat_id = decoded.split("_", 2)
            protect = "/pbatch" if PROTECT_CONTENT else "batch"
        diff = int(l_msg_id) - int(f_msg_id)
        async for msg in client.iter_messages(int(f_chat_id), int(l_msg_id), int(f_msg_id)):
            if msg.media:
                media = getattr(msg, msg.media.value)
                if BATCH_FILE_CAPTION:
                    try:
                        f_caption=BATCH_FILE_CAPTION.format(file_name=getattr(media, 'file_name', ''), file_size=getattr(media, 'file_size', ''), file_caption=getattr(msg, 'caption', ''))
                    except Exception as e:
                        logger.exception(e)
                        f_caption = getattr(msg, 'caption', '')
                else:
                    media = getattr(msg, msg.media.value)
                    file_name = getattr(media, 'file_name', '')
                    f_caption = getattr(msg, 'caption', file_name)
                try:
                    await msg.copy(message.chat.id, caption=f_caption, protect_content=True if protect == "/pbatch" else False)
                except FloodWait as e:
                    await asyncio.sleep(e.x)
                    await msg.copy(message.chat.id, caption=f_caption, protect_content=True if protect == "/pbatch" else False)
                except Exception as e:
                    logger.exception(e)
                    continue
            elif msg.empty:
                continue
            else:
                try:
                    await msg.copy(message.chat.id, protect_content=True if protect == "/pbatch" else False)
                except FloodWait as e:
                    await asyncio.sleep(e.x)
                    await msg.copy(message.chat.id, protect_content=True if protect == "/pbatch" else False)
                except Exception as e:
                    logger.exception(e)
                    continue
            await asyncio.sleep(1) 
        return await sts.delete()

    elif data.split("-", 1)[0] == "verify":
        userid = data.split("-", 2)[1]
        token = data.split("-", 3)[2]
        if str(message.from_user.id) != str(userid):
            return await message.reply_text(
                text="<b>Invalid link or Expired link !</b>",
                protect_content=True
            )
        is_valid = await check_token(client, userid, token)
        if is_valid == True:
            await message.reply_text(
                text=f"<b>Hey {message.from_user.mention}, You are successfully verified !\nNow you have unlimited access for all movies till today midnight.</b>",
                protect_content=True
            )
            await verify_user(client, userid, token)
        else:
            return await message.reply_text(
                text="<b>Invalid link or Expired link !</b>",
                protect_content=True
            )
    if data.startswith("sendfiles"):
        protect_content=True
        current_time = datetime.now(pytz.timezone(TIMEZONE))
        curr_time = current_time.hour        
        if curr_time < 12:
            gtxt = "…¢·¥è·¥è·¥Ö ·¥ç·¥è Ä…¥…™…¥…¢ üëã" 
        elif curr_time < 17:
            gtxt = "…¢·¥è·¥è·¥Ö ·¥Ä“ì·¥õ·¥á Ä…¥·¥è·¥è…¥ üëã" 
        elif curr_time < 21:
            gtxt = "…¢·¥è·¥è·¥Ö ·¥á·¥†·¥á…¥…™…¥…¢ üëã"
        else:
            gtxt = "…¢·¥è·¥è·¥Ö …¥…™…¢ ú·¥õ üëã"
        chat_id = int("-" + file_id.split("-")[1])
        userid = message.from_user.id if message.from_user else None
        g = await get_shortlink(chat_id, f"https://telegram.me/{temp.U_NAME}?start=allfiles_{file_id}")
        k = await client.send_message(chat_id=message.from_user.id,text=" ú·¥á è {message.from_user.mention}, {gtxt}\n\n‚ÄºÔ∏è …¢·¥á·¥õ ·¥Ä ü ü Íú∞…™ ü·¥áÍú± …™…¥ ·¥Ä Íú±…™…¥…¢ ü·¥á  ü…™…¥·¥ã ‚ÄºÔ∏è\n\n‚úÖ  è·¥è·¥ú Ä  ü…™…¥·¥ã …™Íú±  Ä·¥á·¥Ä·¥Ö è, ·¥ã…™…¥·¥Ö ü è ·¥Ñ ü…™·¥Ñ·¥ã ·¥è…¥ ·¥Ö·¥è